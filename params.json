{"name":"Fasthttp","tagline":"Fast HTTP package for Go","body":"# fasthttp\r\nFast HTTP implementation for Go.\r\n\r\nCurrently fasthttp is successfully used in a production serving up to 1M\r\nconcurrent keep-alive connections doing 100K qps from a single server.\r\n\r\n[![Build Status](https://travis-ci.org/valyala/fasthttp.svg)](https://travis-ci.org/valyala/fasthttp)\r\n\r\n[Documentation](https://godoc.org/github.com/valyala/fasthttp)\r\n\r\n[Examples](https://godoc.org/github.com/valyala/fasthttp#pkg-examples)\r\n\r\n[Switching from net/http to fasthttp](#switching-from-nethttp-to-fasthttp)\r\n\r\n[Fasthttp best practicies](#fasthttp-best-practicies)\r\n\r\n[Tricks with byte buffers](#tricks-with-byte-buffers)\r\n\r\n[FAQ](#faq)\r\n\r\n# HTTP server performance comparison with [net/http](https://golang.org/pkg/net/http/)\r\n\r\nIn short, fasthttp server is up to 10 times faster than net/http. Below are benchmark results.\r\n\r\nGOMAXPROCS=1\r\n\r\nnet/http:\r\n```\r\n$ GOMAXPROCS=1 go test -bench=NetHTTPServerGet -benchmem -benchtime=5s\r\nPASS\r\nBenchmarkNetHTTPServerGet1ReqPerConn            \t  300000\t     21236 ns/op\t    2404 B/op\t      30 allocs/op\r\nBenchmarkNetHTTPServerGet2ReqPerConn            \t  500000\t     14634 ns/op\t    2371 B/op\t      24 allocs/op\r\nBenchmarkNetHTTPServerGet10ReqPerConn           \t 1000000\t      9447 ns/op\t    2101 B/op\t      19 allocs/op\r\nBenchmarkNetHTTPServerGet10KReqPerConn          \t 1000000\t      7939 ns/op\t    2033 B/op\t      18 allocs/op\r\nBenchmarkNetHTTPServerGet1ReqPerConn10KClients  \t  300000\t     30291 ns/op\t    4589 B/op\t      31 allocs/op\r\nBenchmarkNetHTTPServerGet2ReqPerConn10KClients  \t  500000\t     23199 ns/op\t    3581 B/op\t      25 allocs/op\r\nBenchmarkNetHTTPServerGet10ReqPerConn10KClients \t  500000\t     13270 ns/op\t    2621 B/op\t      19 allocs/op\r\nBenchmarkNetHTTPServerGet100ReqPerConn10KClients\t  500000\t     11412 ns/op\t    2119 B/op\t      18 allocs/op\r\n```\r\n\r\nfasthttp:\r\n```\r\n$ GOMAXPROCS=1 go test -bench=kServerGet -benchmem -benchtime=5s\r\nPASS\r\nBenchmarkServerGet1ReqPerConn            \t 3000000\t      2341 ns/op\t       0 B/op\t       0 allocs/op\r\nBenchmarkServerGet2ReqPerConn            \t 5000000\t      1799 ns/op\t       0 B/op\t       0 allocs/op\r\nBenchmarkServerGet10ReqPerConn           \t 5000000\t      1239 ns/op\t       0 B/op\t       0 allocs/op\r\nBenchmarkServerGet10KReqPerConn          \t10000000\t      1090 ns/op\t       0 B/op\t       0 allocs/op\r\nBenchmarkServerGet1ReqPerConn10KClients  \t 3000000\t      2860 ns/op\t       4 B/op\t       0 allocs/op\r\nBenchmarkServerGet2ReqPerConn10KClients  \t 3000000\t      1992 ns/op\t       1 B/op\t       0 allocs/op\r\nBenchmarkServerGet10ReqPerConn10KClients \t 5000000\t      1297 ns/op\t       1 B/op\t       0 allocs/op\r\nBenchmarkServerGet100ReqPerConn10KClients\t10000000\t      1264 ns/op\t       9 B/op\t       0 allocs/op\r\n```\r\n\r\nGOMAXPROCS=4\r\n\r\nnet/http:\r\n```\r\n$ GOMAXPROCS=4 go test -bench=NetHTTPServerGet -benchmem -benchtime=5s\r\nPASS\r\nBenchmarkNetHTTPServerGet1ReqPerConn-4            \t 1000000\t      5545 ns/op\t    2433 B/op\t      30 allocs/op\r\nBenchmarkNetHTTPServerGet2ReqPerConn-4            \t 2000000\t      4147 ns/op\t    2398 B/op\t      24 allocs/op\r\nBenchmarkNetHTTPServerGet10ReqPerConn-4           \t 3000000\t      2628 ns/op\t    2118 B/op\t      19 allocs/op\r\nBenchmarkNetHTTPServerGet10KReqPerConn-4          \t 3000000\t      2304 ns/op\t    2037 B/op\t      18 allocs/op\r\nBenchmarkNetHTTPServerGet1ReqPerConn10KClients-4  \t 1000000\t      7327 ns/op\t    3561 B/op\t      30 allocs/op\r\nBenchmarkNetHTTPServerGet2ReqPerConn10KClients-4  \t 1000000\t      5952 ns/op\t    3073 B/op\t      24 allocs/op\r\nBenchmarkNetHTTPServerGet10ReqPerConn10KClients-4 \t 2000000\t      4345 ns/op\t    2530 B/op\t      19 allocs/op\r\nBenchmarkNetHTTPServerGet100ReqPerConn10KClients-4\t 2000000\t      3866 ns/op\t    2132 B/op\t      18 allocs/op\r\n```\r\n\r\nfasthttp:\r\n```\r\n$ GOMAXPROCS=4 go test -bench=kServerGet -benchmem -benchtime=5s\r\nPASS\r\nBenchmarkServerGet1ReqPerConn-4            \t10000000\t      1053 ns/op\t       0 B/op\t       0 allocs/op\r\nBenchmarkServerGet2ReqPerConn-4            \t10000000\t       685 ns/op\t       0 B/op\t       0 allocs/op\r\nBenchmarkServerGet10ReqPerConn-4           \t20000000\t       393 ns/op\t       0 B/op\t       0 allocs/op\r\nBenchmarkServerGet10KReqPerConn-4          \t20000000\t       338 ns/op\t       0 B/op\t       0 allocs/op\r\nBenchmarkServerGet1ReqPerConn10KClients-4  \t10000000\t      1033 ns/op\t       0 B/op\t       0 allocs/op\r\nBenchmarkServerGet2ReqPerConn10KClients-4  \t10000000\t       668 ns/op\t       0 B/op\t       0 allocs/op\r\nBenchmarkServerGet10ReqPerConn10KClients-4 \t20000000\t       393 ns/op\t       0 B/op\t       0 allocs/op\r\nBenchmarkServerGet100ReqPerConn10KClients-4\t20000000\t       384 ns/op\t       4 B/op\t       0 allocs/op\r\n```\r\n\r\n# HTTP client comparison with net/http\r\n\r\nIn short, fasthttp client is up to 10 times faster than net/http. Below are benchmark results.\r\n\r\nGOMAXPROCS=1\r\n\r\nnet/http:\r\n```\r\n$ GOMAXPROCS=1 go test -bench='HTTPClient(Do|GetEndToEnd)' -benchmem -benchtime=5s\r\nPASS\r\nBenchmarkNetHTTPClientDoFastServer\t  500000\t     17535 ns/op\t    2624 B/op\t      38 allocs/op\r\nBenchmarkNetHTTPClientGetEndToEnd \t  200000\t     56593 ns/op\t    5012 B/op\t      59 allocs/op\r\n```\r\n\r\nfasthttp:\r\n```\r\n$ GOMAXPROCS=1 go test -bench='kClient(Do|GetEndToEnd)' -benchmem -benchtime=5s\r\nPASS\r\nBenchmarkClientDoFastServer\t 5000000\t      1420 ns/op\t       0 B/op\t       0 allocs/op\r\nBenchmarkClientGetEndToEnd \t  500000\t     17912 ns/op\t       0 B/op\t       0 allocs/op\r\n```\r\n\r\nGOMAXPROCS=4\r\n\r\nnet/http:\r\n```\r\n$ GOMAXPROCS=4 go test -bench='HTTPClient(Do|GetEndToEnd)' -benchmem -benchtime=5s\r\nPASS\r\nBenchmarkNetHTTPClientDoFastServer-4\t 1000000\t      5795 ns/op\t    2626 B/op\t      38 allocs/op\r\nBenchmarkNetHTTPClientGetEndToEnd-4 \t  500000\t     19304 ns/op\t    5953 B/op\t      62 allocs/op\r\n```\r\n\r\nfasthttp:\r\n```\r\n$ GOMAXPROCS=4 go test -bench='kClient(Do|GetEndToEnd)' -benchmem -benchtime=5s\r\nPASS\r\nBenchmarkClientDoFastServer-4\t20000000\t       443 ns/op\t       0 B/op\t       0 allocs/op\r\nBenchmarkClientGetEndToEnd-4 \t 1000000\t      5954 ns/op\t       0 B/op\t       0 allocs/op\r\n```\r\n\r\n# Switching from net/http to fasthttp\r\n\r\nUnfortunately, fasthttp doesn't provide API identical to net/http.\r\nSee the [FAQ](#faq) for details.\r\n\r\nImportant points:\r\n\r\n* Fasthttp works with [RequestHandler functions](https://godoc.org/github.com/valyala/fasthttp#RequestHandler)\r\ninstead of objects implementing [Handler interface](https://golang.org/pkg/net/http/#Handler).\r\nFortunately, it is easy to pass bound struct methods to fasthttp:\r\n\r\n```go\r\ntype MyHandler struct {\r\n\tfoobar string\r\n}\r\n\r\n// request handler in net/http style, i.e. method bound to MyHandler struct.\r\nfunc (h *MyHandler) HandleFastHTTP(ctx *fasthttp.RequestCtx) {\r\n\t// notice that we may access MyHandler properties here - see h.foobar.\r\n\tfmt.Fprintf(ctx, \"Hello, world! Requested path is %q. Foobar is %q\",\r\n\t\tctx.Path(), h.foobar)\r\n}\r\n\r\n// request handler in fasthttp style, i.e. just plain function.\r\nfunc fastHTTPHandler(ctx *fasthttp.RequestCtx) {\r\n\tfmt.Fprintf(ctx, \"Hi there! RequestURI is %q\", ctx.RequestURI())\r\n}\r\n\r\n// pass bound struct method to fasthttp\r\nmyHandler := &MyHandler{\r\n\tfoobar: \"foobar\",\r\n}\r\nfasthttp.ListenAndServe(\":8080\", myHandler.HandleFastHTTP)\r\n\r\n// pass plain function to fasthttp\r\nfasthttp.ListenAndServe(\":8081\", fastHTTPHandler)\r\n```\r\n\r\n* The [RequestHandler](https://godoc.org/github.com/valyala/fasthttp#RequestHandler)\r\naccepts only one argument - [RequestCtx](https://godoc.org/github.com/valyala/fasthttp#RequestCtx).\r\nIt contains all the functionality required for http request processing\r\nand response writing. Below is an example of a simple request handler conversion\r\nfrom net/http to fasthttp.\r\n\r\n```go\r\n// net/http request handler\r\nrequestHandler := func(w http.ResponseWriter, r *http.Request) {\r\n\tswitch r.URL.Path {\r\n\tcase \"/foo\":\r\n\t\tfooHandler(w, r)\r\n\tcase \"/bar\":\r\n\t\tbarHandler(w, r)\r\n\tdefault:\r\n\t\thttp.Error(w, \"Unsupported path\", http.StatusNotFound)\r\n\t}\r\n}\r\n```\r\n\r\n```go\r\n// the corresponding fasthttp request handler\r\nrequestHandler := func(ctx *fasthttp.RequestCtx) {\r\n\tswitch string(ctx.Path()) {\r\n\tcase \"/foo\":\r\n\t\tfooHandler(ctx)\r\n\tcase \"/bar\":\r\n\t\tbarHandler(ctx)\r\n\tdefault:\r\n\t\tctx.Error(\"Unsupported path\", fasthttp.StatusNotFound)\r\n\t}\r\n}\r\n```\r\n\r\n* Fasthttp allows setting response headers and writing response body\r\nin arbitray order. There is no 'headers first, then body' restriction\r\nlike in net/http. The following code is valid for fasthttp:\r\n```go\r\nrequestHandler := func(ctx *fasthttp.RequestCtx) {\r\n\t// set some headers and status code first\r\n\tctx.SetContentType(\"foo/bar\")\r\n\tctx.SetStatusCode(fasthttp.StatusOK)\r\n\r\n\t// then write the first part of body\r\n\tfmt.Fprintf(ctx, \"this is the first part of body\\n\")\r\n\r\n\t// then set more headers\r\n\tctx.Response.Header.Set(\"Foo-Bar\", \"baz\")\r\n\r\n\t// then write more body\r\n\tfmt.Fprintf(ctx, \"this is the second part of body\\n\")\r\n\r\n\t// then override already written body\r\n\tctx.SetBody([]byte(\"this is completely new body contents\"))\r\n\r\n\t// then update status code\r\n\tctx.SetStatusCode(fasthttp.StatusNotFound)\r\n\r\n\t// basically, anything may be updated many times before\r\n\t// returning from RequestHandler.\r\n\t//\r\n\t// Unlike net/http fasthttp doesn't put response to the wire until\r\n\t// returning from RequestHandler.\r\n}\r\n```\r\n\r\n* Fasthttp doesn't provide [ServeMux](https://golang.org/pkg/net/http/#ServeMux),\r\nsince I believe third-party request routers like [httprouter](https://github.com/julienschmidt/httprouter)\r\nmust be used instead. Net/http code with simple ServeMux is trivially converted\r\nto fasthttp code:\r\n\r\n```go\r\n// net/http code\r\n\r\nm := &http.ServeMux{}\r\nm.HandleFunc(\"/foo\", fooHandlerFunc)\r\nm.HandleFunc(\"/bar\", barHandlerFunc)\r\nm.Handle(\"/baz\", bazHandler)\r\n\r\nhttp.ListenAndServe(\":80\", m)\r\n```\r\n\r\n```go\r\n// the corresponding fasthttp code\r\nm := func(ctx *fasthttp.RequestCtx) {\r\n\tswitch string(ctx.Path()) {\r\n\tcase \"/foo\":\r\n\t\tfooHandlerFunc(ctx)\r\n\tcase \"/bar\":\r\n\t\tbarHandlerFunc(ctx)\r\n\tcase \"/baz\":\r\n\t\tbazHandler.HandlerFunc(ctx)\r\n\tdefault:\r\n\t\tctx.Error(\"not found\", fasthttp.StatusNotFound)\r\n\t}\r\n}\r\n\r\nfastttp.ListenAndServe(\":80\", m)\r\n```\r\n\r\n* net/http -> fasthttp conversion table:\r\n\r\n  * All the pseudocode below assumes w, r and ctx have these types:\r\n  ```go\r\n\tvar (\r\n\t\tw http.ResponseWriter\r\n\t\tr *http.Request\r\n\t\tctx *fasthttp.RequestCtx\r\n\t)\r\n  ```\r\n  * r.Body -> [ctx.PostBody()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.PostBody)\r\n  * r.URL.Path -> [ctx.Path()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Path)\r\n  * r.URL -> [ctx.URI()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.URI)\r\n  * r.Method -> [ctx.Method()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Method)\r\n  * r.Header -> [ctx.Request.Header](https://godoc.org/github.com/valyala/fasthttp#RequestHeader)\r\n  * r.Header.Get() -> [ctx.Request.Header.Peek()](https://godoc.org/github.com/valyala/fasthttp#RequestHeader.Peek)\r\n  * r.Host -> [ctx.Host()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Host)\r\n  * r.Form -> [ctx.QueryArgs()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.QueryArgs) +\r\n  [ctx.PostArgs()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.PostArgs)\r\n  * r.PostForm -> [ctx.PostArgs()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.PostArgs)\r\n  * r.FormValue() -> [ctx.QueryArgs().Peek()](https://godoc.org/github.com/valyala/fasthttp#Args.Peek)\r\n  * r.MultipartForm -> [ctx.MultipartForm()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.MultipartForm)\r\n  * r.RemoteAddr -> [ctx.RemoteAddr()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.RemoteAddr)\r\n  * r.RequestURI -> [ctx.RequestURI()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.RequestURI)\r\n  * r.TLS -> [ctx.IsTLS()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.IsTLS)\r\n  * r.Cookie() -> [ctx.Request.Header.Cookie()](https://godoc.org/github.com/valyala/fasthttp#RequestHeader.Cookie)\r\n  * r.Referer() -> [ctx.Referer()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Referer)\r\n  * r.UserAgent() -> [ctx.Request.Header.UserAgent()](https://godoc.org/github.com/valyala/fasthttp#RequestHeader.UserAgent)\r\n  * w.Header() -> [ctx.Response.Header](https://godoc.org/github.com/valyala/fasthttp#ResponseHeader)\r\n  * w.Header().Set() -> [ctx.Response.Header.Set()](https://godoc.org/github.com/valyala/fasthttp#ResponseHeader.Set)\r\n  * w.Header().Set(\"Content-Type\") -> [ctx.SetContentType()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.SetContentType)\r\n  * w.Header().Set(\"Set-Cookie\") -> [ctx.Response.Header.SetCookie()](https://godoc.org/github.com/valyala/fasthttp#ResponseHeader.SetCookie)\r\n  * w.Write() -> [ctx.Write()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Write),\r\n  [ctx.SetBody()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.SetBody),\r\n  [ctx.SetBodyStream()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.SetBodyStream)\r\n  * w.WriteHeader() -> [ctx.SetStatusCode()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.SetStatusCode)\r\n  * w.(http.Hijacker).Hijack() -> [ctx.Hijack()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Hijack)\r\n  * http.Error() -> [ctx.Error()](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Error)\r\n\r\n* *VERY IMPORTANT!* Fasthttp disallows holding references\r\nto [RequestCtx](https://godoc.org/github.com/valyala/fasthttp#RequestCtx) or to its'\r\nmembers after returning from [RequestHandler](https://godoc.org/github.com/valyala/fasthttp#RequestHandler).\r\nOtherwise [data races](http://blog.golang.org/race-detector) are unevitable.\r\nCarefully inspect all the net/http request handlers converted to fasthttp whether\r\nthey retain references to RequestCtx or to its' members after returning.\r\nRequestCtx provides the following _band aids_ for this case:\r\n\r\n  * Wrap RequestHandler into [TimeoutHandler](https://godoc.org/github.com/valyala/fasthttp#TimeoutHandler).\r\n  * Call [TimeoutError](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.TimeoutError)\r\n  before returning from RequestHandler if there are references to RequestCtx or to its' members.\r\n  See [the example](https://godoc.org/github.com/valyala/fasthttp#example-RequestCtx-TimeoutError)\r\n  for more details.\r\n\r\nUse brilliant tool - [race detector](http://blog.golang.org/race-detector) -\r\nfor detecting and eliminating data races in your program. If you detected\r\ndata race related to fasthttp in your program, then there is high probability\r\nyou forgot calling [TimeoutError](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.TimeoutError)\r\nbefore returning from [RequestHandler](https://godoc.org/github.com/valyala/fasthttp#RequestHandler).\r\n\r\n* Blind switching from net/http to fasthttp won't give you performance boost.\r\nWhile fasthttp is optimized for speed, its' performance may be easily saturated\r\nby slow [RequestHandler](https://godoc.org/github.com/valyala/fasthttp#RequestHandler).\r\nSo [profile](http://blog.golang.org/profiling-go-programs) and optimize your\r\ncode after switching to fasthttp.\r\n\r\n\r\n# Performance optimization tips for multi-core systems\r\n\r\n* Use [reuseport](https://godoc.org/github.com/valyala/fasthttp/reuseport) listener.\r\n* Run a separate server instance per CPU core with GOMAXPROCS=1.\r\n* Pin each server instance to a separate CPU core using [taskset](http://linux.die.net/man/1/taskset).\r\n* Ensure the interrupts of multiqueue network card are evenly distributed between CPU cores.\r\n  See [this article](https://blog.cloudflare.com/how-to-achieve-low-latency/) for details.\r\n\r\n\r\n# Fasthttp best practicies\r\n\r\n* Do not allocate objects and `[]byte` buffers - just reuse them as much\r\n  as possible. Fasthttp API design encourages this.\r\n* [sync.Pool](https://golang.org/pkg/sync/#Pool) is your best friend.\r\n* [Profile your program](http://blog.golang.org/profiling-go-programs)\r\n  in production.\r\n  `go tool pprof --alloc_objects your-program mem.pprof` usually gives better\r\n  insights for optimization opportunities than `go tool pprof your-program cpu.pprof`.\r\n* Write [tests and benchmarks](https://golang.org/pkg/testing/) for hot paths.\r\n* Avoid conversion between `[]byte` and `string`, since this may result in memory\r\n  allocation+copy. Fasthttp API provides functions for both `[]byte` and `string` -\r\n  use these functions instead of converting manually between `[]byte` and `string`.\r\n* Verify your tests and production code under\r\n  [race detector](https://golang.org/doc/articles/race_detector.html) on a regular basis.\r\n\r\n\r\n# Tricks with `[]byte` buffers\r\n\r\nThe following tricks are used by fasthttp. Use them in your code too.\r\n\r\n* Standard Go functions accept nil buffers\r\n```go\r\nvar (\r\n\t// both buffers are uninitialized\r\n\tdst []byte\r\n\tsrc []byte\r\n)\r\ndst = append(dst, src...)  // this is legal code\r\ncopy(dst, src)  // this is legal code\r\n(string(src) == \"\")  // is true\r\n(len(src) == 0)  // is true\r\n```\r\n\r\nSo throw away nil checks for `[]byte` buffers from you code. For example,\r\n```go\r\nsrcLen := 0\r\nif src != nil {\r\n\tsrcLen = len(src)\r\n}\r\n```\r\n\r\nbecomes\r\n\r\n```go\r\nsrcLen := len(src)\r\n```\r\n\r\n* String may be appended to `[]byte` buffer with `append`\r\n```go\r\ndst = append(dst, \"foobar\"...)\r\n```\r\n\r\n* All fasthttp functions accept nil `[]byte` buffer\r\n```go\r\nstatusCode, body, err := fasthttp.Get(nil, \"http://google.com/\")\r\nuintBuf := fasthttp.AppendUint(nil, 1234)\r\n```\r\n\r\n# FAQ\r\n\r\n* *Why creating yet another http package instead of optimizing net/http?*\r\n\r\n  Because net/http API limits many optimization opportunities.\r\n  For example:\r\n  * net/http Request object lifetime isn't limited by request handler execution\r\n    time. So the server must create new request object per each request instead\r\n    of reusing existing objects like fasthttp do.\r\n  * net/http headers are stored in a `map[string][]string`. So the server\r\n    must parse all the headers, convert them from `[]byte` to `string` and put\r\n    them into the map before calling user-provided request handler.\r\n    This all requires unnesessary memory allocations avoided by fasthttp.\r\n  * net/http client API requires creating new response object per each request.\r\n\r\n* *Why fasthttp API is incompatible with net/http?*\r\n\r\n  Because net/http API limits many optimization opportunities. See the answer\r\n  above for more details. Also certain net/http API parts are suboptimal\r\n  for use:\r\n  * Compare [net/http connection hijacking](https://golang.org/pkg/net/http/#Hijacker)\r\n    to [fasthttp connection hijacking](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Hijack).\r\n  * Compare [net/http Request.Body reading](https://golang.org/pkg/net/http/#Request)\r\n    to [fasthttp request body reading](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.PostBody).\r\n\r\n* *Why fasthttp doesn't support HTTP/2.0 and WebSockets?*\r\n\r\n  There are [plans](TODO) for adding HTTP/2.0 and WebSockets support\r\n  in the future.\r\n  In the mean time, third parties may use [RequestCtx.Hijack](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.Hijack)\r\n  for implementing these goodies.\r\n\r\n* *Are there known net/http advantages comparing to fasthttp?*\r\n\r\n  Yes:\r\n  * net/http supports [HTTP/2.0 starting from go1.6](https://http2.golang.org/).\r\n  * net/http API is stable, while fasthttp API constantly evolves.\r\n  * net/http handles more HTTP corner cases.\r\n  * net/http should contain less bugs, since it is used and tested by much\r\n    wider audience.\r\n  * Many existing web frameworks and request routers are built on top\r\n    of net/http.\r\n  * net/http works on Go older than 1.5.\r\n\r\n* *Which GO versions are supported by fasthttp?*\r\n\r\n  Go1.5+. Older versions won't be supported, since their standard package\r\n  [miss useful functions](https://github.com/valyala/fasthttp/issues/5).\r\n\r\n* *Please provide real benchmark data and sever information*\r\n\r\n  See [this issue](https://github.com/valyala/fasthttp/issues/4).\r\n\r\n* *Are there plans to add request routing to fasthttp?*\r\n\r\n  There are no plans to add request routing into fasthttp. I believe request\r\n  routing must be implemented in a separate package(s) like\r\n  [httprouter](https://github.com/julienschmidt/httprouter).\r\n  See [this issue](https://github.com/valyala/fasthttp/issues/8) for more info.\r\n\r\n* *I detected data race in fasthttp!*\r\n\r\n  Cool! [File a bug](https://github.com/valyala/fasthttp/issues/new). But before\r\n  doing this check the following in your code:\r\n\r\n  * Make sure there are no references to [RequestCtx](https://godoc.org/github.com/valyala/fasthttp#RequestCtx)\r\n  or to its' members after returning from [RequestHandler](https://godoc.org/github.com/valyala/fasthttp#RequestHandler).\r\n  * Make sure you call [TimeoutError](https://godoc.org/github.com/valyala/fasthttp#RequestCtx.TimeoutError)\r\n  before returning from [RequestHandler](https://godoc.org/github.com/valyala/fasthttp#RequestHandler)\r\n  if there are references to [RequestCtx](https://godoc.org/github.com/valyala/fasthttp#RequestCtx)\r\n  or to its' members, which may be accessed by other goroutines.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}